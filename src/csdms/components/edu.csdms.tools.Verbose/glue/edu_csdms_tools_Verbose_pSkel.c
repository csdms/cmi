/*
 * File:          edu_csdms_tools_Verbose_pSkel.c
 * Symbol:        edu.csdms.tools.Verbose-v0.0
 * Symbol Type:   class
 * Babel Version: 1.4.0 (Revision: 6607 release-1-4-0-branch)
 * Description:   skeletons to link IOR to Python implementation
 * 
 * WARNING: Automatically generated; changes will be lost
 * 
 */

/*
 * THIS CODE IS AUTOMATICALLY GENERATED BY THE BABEL
 * COMPILER. DO NOT EDIT THIS!
 * 
 * This file contains skeleton code to provide an interface
 * between the sidl independent object representation and
 * the Python implementation of a class.  This translates
 * method calls to the IOR to method class in Python.
 * This file is for the sidl type edu.csdms.tools.Verbose.
 */


#include <Python.h>
#ifndef included_edu_csdms_tools_Verbose_IOR_h
#include "edu_csdms_tools_Verbose_IOR.h"
#endif
#include "sidlObjA.h"
#include "sidlPyArrays.h"
#ifdef SIDL_HAVE_NUMPY
#include "oldnumeric.h"
#elif defined(SIDL_HAVE_NUMERIC_PYTHON)
#include "Numeric/arrayobject.h"
#else
#error Neither Numeric Python nor NumPy installed
#endif
#ifndef included_sidl_header_h
#include "sidl_header.h"
#endif
#ifndef included_sidl_Python_h
#include "sidl_Python.h"
#endif
#include "sidl_BaseInterface_Module.h"
#include "edu_csdms_tools_Verbose_Module.h"
#include "sidl_ClassInfo_Module.h"
#include "sidl_RuntimeException_Module.h"
#include <stdlib.h>
#include <string.h>

struct edu_csdms_tools_Verbose__rmiExternals {
  struct sidl_BaseInterface__object* (
    *f_pskel_edu_csdms_tools_Verbose_fconnect_sidl_BaseInterface)(
    /* in */ const char* url,
    /* in */ sidl_bool ar,
    /* out */ struct sidl_BaseInterface__object **_ex);

};
static void _importModules(void) {
  static int _import = 1;
  if (_import) {
    PyGILState_STATE _gstate;
    _import = 0;
#if (PY_VERSION_HEX >= 0x02040000)
    _gstate = PyGILState_Ensure();
    sidl_Python_LogGILEnsure(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
    import_SIDLObjA();
    import_SIDLPyArrays();
    edu_csdms_tools_Verbose__import();
    sidl_BaseInterface__import();
    sidl_ClassInfo__import();
    sidl_RuntimeException__import();
#if (PY_VERSION_HEX >= 0x02040000)
    PyGILState_Release(_gstate);
    sidl_Python_LogGILRelease(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
  }
}

static void
pSkel_Verbose_boccaForceUsePortInclude(
  /* in */ struct edu_csdms_tools_Verbose__object *self,
  struct sidl_BaseInterface__object * *_exception
  )
{
  PyObject *_context;
  PyObject *_pfunc;
  PyObject *_args;
  PyObject *_result;
  PyGILState_STATE _gstate;
  *_exception = NULL;
#if (PY_VERSION_HEX >= 0x02040000)
  _gstate = PyGILState_Ensure();
  sidl_Python_LogGILEnsure(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
  if ((_context = (self ? self->d_data : NULL))) {
    if ((_pfunc = PyObject_GetAttrString(_context, 
      "boccaForceUsePortInclude"))) {
      _args = PyTuple_New(0);
      if (_args) {
        _result = PyObject_CallObject(_pfunc, _args);
        if (_result) {
          int _okay;
          _okay = (_result == Py_None);
          if (_okay) {
          }
          Py_DECREF(_result);
        }
        else {
          if (PyErr_Occurred()) {
            PyObject *_exType, *_exValue, *_exTrace;
            PyErr_Fetch(&_exType, &_exValue, &_exTrace);
            if (PyErr_GivenExceptionMatches(_exType, 
              sidl_RuntimeException__type)) {
              struct sidl_RuntimeException__object *_local_exception = NULL;
              PyObject *_sidlPyException = 
                PyObject_GetAttrString(_exValue, "exception");
              (void)sidl_RuntimeException__convert(_sidlPyException , 
                &_local_exception);
              if (_local_exception) {
                sidl_AddTrace(_sidlPyException, "boccaForceUsePortInclude");
                *_exception = (struct sidl_BaseInterface__object 
                  *)_local_exception;
              }
              Py_XDECREF(_sidlPyException);
            }
            else {
              PyErr_Restore(_exType, _exValue, _exTrace);
              *_exception = sidl_Handle_Unexpected("boccaForceUsePortInclude");
              _exType = NULL;
              _exValue = NULL;
              _exTrace = NULL;
            }
            Py_XDECREF(_exType);
            Py_XDECREF(_exValue);
            Py_XDECREF(_exTrace);
            PyErr_Clear();
          }
        }
        Py_DECREF(_args);
      } else {
        *_exception = sidl_Handle_Unexpected("boccaForceUsePortInclude");
      }
      Py_DECREF(_pfunc);
    } else {
      *_exception = sidl_Handle_Unexpected("boccaForceUsePortInclude");
    }
  }
#if (PY_VERSION_HEX >= 0x02040000)
  PyGILState_Release(_gstate);
  sidl_Python_LogGILRelease(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
}

static void
pSkel_Verbose_set_log_level(
  /* in */ struct edu_csdms_tools_Verbose__object *self,
  /* in */ int32_t level,
  struct sidl_BaseInterface__object * *_exception
  )
{
  PyObject *_context;
  PyObject *_pfunc;
  PyObject *_args;
  PyObject *_result;
  PyGILState_STATE _gstate;
  *_exception = NULL;
#if (PY_VERSION_HEX >= 0x02040000)
  _gstate = PyGILState_Ensure();
  sidl_Python_LogGILEnsure(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
  if ((_context = (self ? self->d_data : NULL))) {
    if ((_pfunc = PyObject_GetAttrString(_context, "set_log_level"))) {
      long _proxy_level;
      _proxy_level = level;
      _args =Py_BuildValue(
        "(l)",
        _proxy_level);
      if (_args) {
        _result = PyObject_CallObject(_pfunc, _args);
        if (_result) {
          int _okay;
          _okay = (_result == Py_None);
          if (_okay) {
          }
          Py_DECREF(_result);
        }
        else {
          if (PyErr_Occurred()) {
            PyObject *_exType, *_exValue, *_exTrace;
            PyErr_Fetch(&_exType, &_exValue, &_exTrace);
            if (PyErr_GivenExceptionMatches(_exType, 
              sidl_RuntimeException__type)) {
              struct sidl_RuntimeException__object *_local_exception = NULL;
              PyObject *_sidlPyException = 
                PyObject_GetAttrString(_exValue, "exception");
              (void)sidl_RuntimeException__convert(_sidlPyException , 
                &_local_exception);
              if (_local_exception) {
                sidl_AddTrace(_sidlPyException, "set_log_level");
                *_exception = (struct sidl_BaseInterface__object 
                  *)_local_exception;
              }
              Py_XDECREF(_sidlPyException);
            }
            else {
              PyErr_Restore(_exType, _exValue, _exTrace);
              *_exception = sidl_Handle_Unexpected("set_log_level");
              _exType = NULL;
              _exValue = NULL;
              _exTrace = NULL;
            }
            Py_XDECREF(_exType);
            Py_XDECREF(_exValue);
            Py_XDECREF(_exTrace);
            PyErr_Clear();
          }
        }
        Py_DECREF(_args);
      } else {
        *_exception = sidl_Handle_Unexpected("set_log_level");
      }
      Py_DECREF(_pfunc);
    } else {
      *_exception = sidl_Handle_Unexpected("set_log_level");
    }
  }
#if (PY_VERSION_HEX >= 0x02040000)
  PyGILState_Release(_gstate);
  sidl_Python_LogGILRelease(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
}

static void
pSkel_Verbose_log(
  /* in */ struct edu_csdms_tools_Verbose__object *self,
  /* in */ int32_t level,
  /* in */ const char* message,
  struct sidl_BaseInterface__object * *_exception
  )
{
  PyObject *_context;
  PyObject *_pfunc;
  PyObject *_args;
  PyObject *_result;
  PyGILState_STATE _gstate;
  *_exception = NULL;
#if (PY_VERSION_HEX >= 0x02040000)
  _gstate = PyGILState_Ensure();
  sidl_Python_LogGILEnsure(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
  if ((_context = (self ? self->d_data : NULL))) {
    if ((_pfunc = PyObject_GetAttrString(_context, "log"))) {
      long _proxy_level;
      _proxy_level = level;
      _args =Py_BuildValue(
        "(lz)",
        _proxy_level,
        message);
      if (_args) {
        _result = PyObject_CallObject(_pfunc, _args);
        if (_result) {
          int _okay;
          _okay = (_result == Py_None);
          if (_okay) {
          }
          Py_DECREF(_result);
        }
        else {
          if (PyErr_Occurred()) {
            PyObject *_exType, *_exValue, *_exTrace;
            PyErr_Fetch(&_exType, &_exValue, &_exTrace);
            if (PyErr_GivenExceptionMatches(_exType, 
              sidl_RuntimeException__type)) {
              struct sidl_RuntimeException__object *_local_exception = NULL;
              PyObject *_sidlPyException = 
                PyObject_GetAttrString(_exValue, "exception");
              (void)sidl_RuntimeException__convert(_sidlPyException , 
                &_local_exception);
              if (_local_exception) {
                sidl_AddTrace(_sidlPyException, "log");
                *_exception = (struct sidl_BaseInterface__object 
                  *)_local_exception;
              }
              Py_XDECREF(_sidlPyException);
            }
            else {
              PyErr_Restore(_exType, _exValue, _exTrace);
              *_exception = sidl_Handle_Unexpected("log");
              _exType = NULL;
              _exValue = NULL;
              _exTrace = NULL;
            }
            Py_XDECREF(_exType);
            Py_XDECREF(_exValue);
            Py_XDECREF(_exTrace);
            PyErr_Clear();
          }
        }
        Py_DECREF(_args);
      } else {
        *_exception = sidl_Handle_Unexpected("log");
      }
      Py_DECREF(_pfunc);
    } else {
      *_exception = sidl_Handle_Unexpected("log");
    }
  }
#if (PY_VERSION_HEX >= 0x02040000)
  PyGILState_Release(_gstate);
  sidl_Python_LogGILRelease(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
}

static void
pSkel_Verbose__ctor(
  /* in */ struct edu_csdms_tools_Verbose__object *self,
  struct sidl_BaseInterface__object * *_exception
  )
{
  PyObject *_context;
  PyObject *_pfunc;
  PyObject *_args;
  PyObject *_result;
  PyGILState_STATE _gstate;
  *_exception = NULL;
#if (PY_VERSION_HEX >= 0x02040000)
  _gstate = PyGILState_Ensure();
  sidl_Python_LogGILEnsure(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
  if ((_context = PyImport_ImportModule("edu.csdms.tools.Verbose_Impl"))) {
    if ((_pfunc = PyObject_GetAttrString(_context, "Verbose"))) {
      _args = Py_BuildValue("(O&)", (void *)
        edu_csdms_tools_Verbose__weakRef, self);
      if (_args) {
        _result = PyInstance_New(_pfunc, _args, NULL);
        if (_result) {
          self->d_data = _result;
          sidl_Python_IncGlobalRef();
        }
        else {
          *_exception = sidl_Handle_Unexpected("_ctor");
        }
        Py_DECREF(_args);
      } else {
        *_exception = sidl_Handle_Unexpected("_ctor");
      }
      Py_DECREF(_pfunc);
    } else {
      *_exception = sidl_Handle_Unexpected("_ctor");
    }
    Py_DECREF(_context);
  } else {
    *_exception = sidl_Handle_Unexpected("_ctor");
  }
#if (PY_VERSION_HEX >= 0x02040000)
  PyGILState_Release(_gstate);
  sidl_Python_LogGILRelease(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
}

/* ctor2, unused in Python. */
static void
pSkel_Verbose__ctor2(
  /* in */ struct edu_csdms_tools_Verbose__object *self,
  /* in */ void* private_data,
  struct sidl_BaseInterface__object * *_exception
  )
{
  *_exception = NULL;
}
static void
pSkel_Verbose__dtor(
  /* in */ struct edu_csdms_tools_Verbose__object *self,
  struct sidl_BaseInterface__object * *_exception
  )
{
  PyGILState_STATE _gstate;
  *_exception = NULL;
#if (PY_VERSION_HEX >= 0x02040000)
  _gstate = PyGILState_Ensure();
  sidl_Python_LogGILEnsure(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
  /* Remove only reference to Python object */
  Py_XDECREF(((PyObject *)self->d_data));
#if (PY_VERSION_HEX >= 0x02040000)
  PyGILState_Release(_gstate);
  sidl_Python_LogGILRelease(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
  sidl_Python_DecGlobalRef();
}

#ifdef __cplusplus
extern "C" {
#endif

void
edu_csdms_tools_Verbose__impl_set_epv(struct edu_csdms_tools_Verbose__epv *epv,
  struct edu_csdms_tools_Verbose__pre_epv *pre_epv, struct 
    edu_csdms_tools_Verbose__post_epv *post_epv)
{
  _importModules();
  epv->f__ctor = pSkel_Verbose__ctor;
  epv->f__ctor2 = pSkel_Verbose__ctor2;
  epv->f__dtor = pSkel_Verbose__dtor;
  pre_epv->f_boccaForceUsePortInclude_pre = NULL;
  epv->f_boccaForceUsePortInclude = pSkel_Verbose_boccaForceUsePortInclude;
  post_epv->f_boccaForceUsePortInclude_post = NULL;
  pre_epv->f_set_log_level_pre = NULL;
  epv->f_set_log_level = pSkel_Verbose_set_log_level;
  post_epv->f_set_log_level_post = NULL;
  pre_epv->f_log_pre = NULL;
  epv->f_log = pSkel_Verbose_log;
  post_epv->f_log_post = NULL;
}
#ifdef __cplusplus
}
#endif

static struct sidl_BaseInterface__object* 
  pskel_edu_csdms_tools_Verbose_fconnect_sidl_BaseInterface(const char* url, 
  sidl_bool ar, struct sidl_BaseInterface__object* *_ex) { 
  sidl_BaseInterface__import();
  return sidl_BaseInterface__connectI(url, ar, _ex);
}

#ifdef WITH_RMI
static struct edu_csdms_tools_Verbose__rmiExternals s_rmiExtern = {
  pskel_edu_csdms_tools_Verbose_fconnect_sidl_BaseInterface
};

#ifdef __cplusplus
extern "C" {
#endif

struct edu_csdms_tools_Verbose__rmiExternals *
edu_csdms_tools_Verbose__impl_rmi_externals(void) {
  return &s_rmiExtern;
}
#ifdef __cplusplus
}
#endif

#endif /*WITH_RMI*/
