/*
 * File:          edu_csdms_tools_PrintQueue_pSkel.c
 * Symbol:        edu.csdms.tools.PrintQueue-v0.0
 * Symbol Type:   class
 * Babel Version: 1.4.0 (Revision: 6607 release-1-4-0-branch)
 * Description:   skeletons to link IOR to Python implementation
 * 
 * WARNING: Automatically generated; changes will be lost
 * 
 */

/*
 * THIS CODE IS AUTOMATICALLY GENERATED BY THE BABEL
 * COMPILER. DO NOT EDIT THIS!
 * 
 * This file contains skeleton code to provide an interface
 * between the sidl independent object representation and
 * the Python implementation of a class.  This translates
 * method calls to the IOR to method class in Python.
 * This file is for the sidl type edu.csdms.tools.PrintQueue.
 */


#include <Python.h>
#ifndef included_edu_csdms_tools_PrintQueue_IOR_h
#include "edu_csdms_tools_PrintQueue_IOR.h"
#endif
#include "sidlObjA.h"
#include "sidlPyArrays.h"
#ifdef SIDL_HAVE_NUMPY
#include "oldnumeric.h"
#elif defined(SIDL_HAVE_NUMERIC_PYTHON)
#include "Numeric/arrayobject.h"
#else
#error Neither Numeric Python nor NumPy installed
#endif
#ifndef included_sidl_header_h
#include "sidl_header.h"
#endif
#ifndef included_sidl_Python_h
#include "sidl_Python.h"
#endif
#include "sidl_BaseInterface_Module.h"
#include "edu_csdms_tools_PrintQueue_Module.h"
#include "edu_csdms_ports_IRFPort_Module.h"
#include "edu_csdms_tools_IRasterOutputFile_Module.h"
#include "gov_cca_TypeMap_Module.h"
#include "sidl_ClassInfo_Module.h"
#include "sidl_RuntimeException_Module.h"
#include <stdlib.h>
#include <string.h>

struct edu_csdms_tools_PrintQueue__rmiExternals {
  struct edu_csdms_ports_IRFPort__object* (
    *f_pskel_edu_csdms_tools_PrintQueue_fconnect_edu_csdms_ports_IRFPort)(
    /* in */ const char* url,
    /* in */ sidl_bool ar,
    /* out */ struct sidl_BaseInterface__object **_ex);

  struct edu_csdms_tools_IRasterOutputFile__object* (
    *f_pskel_edu_csdms_tools_PrintQueue_fconnect_edu_csdms_tools_IRasterOutputFile)
    (
    /* in */ const char* url,
    /* in */ sidl_bool ar,
    /* out */ struct sidl_BaseInterface__object **_ex);

  struct gov_cca_TypeMap__object* (
    *f_pskel_edu_csdms_tools_PrintQueue_fconnect_gov_cca_TypeMap)(
    /* in */ const char* url,
    /* in */ sidl_bool ar,
    /* out */ struct sidl_BaseInterface__object **_ex);

  struct sidl_BaseInterface__object* (
    *f_pskel_edu_csdms_tools_PrintQueue_fconnect_sidl_BaseInterface)(
    /* in */ const char* url,
    /* in */ sidl_bool ar,
    /* out */ struct sidl_BaseInterface__object **_ex);

};
static void _importModules(void) {
  static int _import = 1;
  if (_import) {
    PyGILState_STATE _gstate;
    _import = 0;
#if (PY_VERSION_HEX >= 0x02040000)
    _gstate = PyGILState_Ensure();
    sidl_Python_LogGILEnsure(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
    import_SIDLObjA();
    import_SIDLPyArrays();
    edu_csdms_tools_PrintQueue__import();
    edu_csdms_ports_IRFPort__import();
    edu_csdms_tools_IRasterOutputFile__import();
    gov_cca_TypeMap__import();
    sidl_BaseInterface__import();
    sidl_ClassInfo__import();
    sidl_RuntimeException__import();
#if (PY_VERSION_HEX >= 0x02040000)
    PyGILState_Release(_gstate);
    sidl_Python_LogGILRelease(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
  }
}

static void
pSkel_PrintQueue_initialize(
  /* in */ struct edu_csdms_tools_PrintQueue__object *self,
  /* in */ struct gov_cca_TypeMap__object* userinput,
  /* in */ const char* base_namespace,
  /* in */ struct edu_csdms_ports_IRFPort__object* port,
  struct sidl_BaseInterface__object * *_exception
  )
{
  PyObject *_context;
  PyObject *_pfunc;
  PyObject *_args;
  PyObject *_result;
  PyGILState_STATE _gstate;
  *_exception = NULL;
#if (PY_VERSION_HEX >= 0x02040000)
  _gstate = PyGILState_Ensure();
  sidl_Python_LogGILEnsure(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
  if ((_context = (self ? self->d_data : NULL))) {
    if ((_pfunc = PyObject_GetAttrString(_context, "initialize"))) {
      _args =Py_BuildValue(
        "(O&zO&)",
        (void *)gov_cca_TypeMap__newRef, userinput,
        base_namespace,
        (void *)edu_csdms_ports_IRFPort__newRef, port);
      if (_args) {
        _result = PyObject_CallObject(_pfunc, _args);
        if (_result) {
          int _okay;
          _okay = (_result == Py_None);
          if (_okay) {
          }
          Py_DECREF(_result);
        }
        else {
          if (PyErr_Occurred()) {
            PyObject *_exType, *_exValue, *_exTrace;
            PyErr_Fetch(&_exType, &_exValue, &_exTrace);
            if (PyErr_GivenExceptionMatches(_exType, 
              sidl_RuntimeException__type)) {
              struct sidl_RuntimeException__object *_local_exception = NULL;
              PyObject *_sidlPyException = 
                PyObject_GetAttrString(_exValue, "exception");
              (void)sidl_RuntimeException__convert(_sidlPyException , 
                &_local_exception);
              if (_local_exception) {
                sidl_AddTrace(_sidlPyException, "initialize");
                *_exception = (struct sidl_BaseInterface__object 
                  *)_local_exception;
              }
              Py_XDECREF(_sidlPyException);
            }
            else {
              PyErr_Restore(_exType, _exValue, _exTrace);
              *_exception = sidl_Handle_Unexpected("initialize");
              _exType = NULL;
              _exValue = NULL;
              _exTrace = NULL;
            }
            Py_XDECREF(_exType);
            Py_XDECREF(_exValue);
            Py_XDECREF(_exTrace);
            PyErr_Clear();
          }
        }
        Py_DECREF(_args);
      } else {
        *_exception = sidl_Handle_Unexpected("initialize");
      }
      Py_DECREF(_pfunc);
    } else {
      *_exception = sidl_Handle_Unexpected("initialize");
    }
  }
#if (PY_VERSION_HEX >= 0x02040000)
  PyGILState_Release(_gstate);
  sidl_Python_LogGILRelease(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
}

static void
pSkel_PrintQueue_add_files(
  /* in */ struct edu_csdms_tools_PrintQueue__object *self,
  /* in */ const char* var_namespace,
  struct sidl_BaseInterface__object * *_exception
  )
{
  PyObject *_context;
  PyObject *_pfunc;
  PyObject *_args;
  PyObject *_result;
  PyGILState_STATE _gstate;
  *_exception = NULL;
#if (PY_VERSION_HEX >= 0x02040000)
  _gstate = PyGILState_Ensure();
  sidl_Python_LogGILEnsure(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
  if ((_context = (self ? self->d_data : NULL))) {
    if ((_pfunc = PyObject_GetAttrString(_context, "add_files"))) {
      _args =Py_BuildValue(
        "(z)",
        var_namespace);
      if (_args) {
        _result = PyObject_CallObject(_pfunc, _args);
        if (_result) {
          int _okay;
          _okay = (_result == Py_None);
          if (_okay) {
          }
          Py_DECREF(_result);
        }
        else {
          if (PyErr_Occurred()) {
            PyObject *_exType, *_exValue, *_exTrace;
            PyErr_Fetch(&_exType, &_exValue, &_exTrace);
            if (PyErr_GivenExceptionMatches(_exType, 
              sidl_RuntimeException__type)) {
              struct sidl_RuntimeException__object *_local_exception = NULL;
              PyObject *_sidlPyException = 
                PyObject_GetAttrString(_exValue, "exception");
              (void)sidl_RuntimeException__convert(_sidlPyException , 
                &_local_exception);
              if (_local_exception) {
                sidl_AddTrace(_sidlPyException, "add_files");
                *_exception = (struct sidl_BaseInterface__object 
                  *)_local_exception;
              }
              Py_XDECREF(_sidlPyException);
            }
            else {
              PyErr_Restore(_exType, _exValue, _exTrace);
              *_exception = sidl_Handle_Unexpected("add_files");
              _exType = NULL;
              _exValue = NULL;
              _exTrace = NULL;
            }
            Py_XDECREF(_exType);
            Py_XDECREF(_exValue);
            Py_XDECREF(_exTrace);
            PyErr_Clear();
          }
        }
        Py_DECREF(_args);
      } else {
        *_exception = sidl_Handle_Unexpected("add_files");
      }
      Py_DECREF(_pfunc);
    } else {
      *_exception = sidl_Handle_Unexpected("add_files");
    }
  }
#if (PY_VERSION_HEX >= 0x02040000)
  PyGILState_Release(_gstate);
  sidl_Python_LogGILRelease(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
}

static double
pSkel_PrintQueue_next_print_time(
  /* in */ struct edu_csdms_tools_PrintQueue__object *self,
  struct sidl_BaseInterface__object * *_exception
  )
{
  PyObject *_context;
  PyObject *_pfunc;
  PyObject *_args;
  PyObject *_result;
  PyGILState_STATE _gstate;
  double _return = (double) 0;
  *_exception = NULL;
#if (PY_VERSION_HEX >= 0x02040000)
  _gstate = PyGILState_Ensure();
  sidl_Python_LogGILEnsure(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
  if ((_context = (self ? self->d_data : NULL))) {
    if ((_pfunc = PyObject_GetAttrString(_context, "next_print_time"))) {
      _args = PyTuple_New(0);
      if (_args) {
        _result = PyObject_CallObject(_pfunc, _args);
        if (_result) {
          int _okay;
          PyObject *_tmp = PyTuple_New(1);
          (void)PyTuple_SetItem(_tmp, 0, _result);
          _result = _tmp;
          _okay = PyArg_ParseTuple(_result, 
            "d",
            &_return);
          if (_okay) {
          }
          Py_DECREF(_result);
        }
        else {
          if (PyErr_Occurred()) {
            PyObject *_exType, *_exValue, *_exTrace;
            PyErr_Fetch(&_exType, &_exValue, &_exTrace);
            if (PyErr_GivenExceptionMatches(_exType, 
              sidl_RuntimeException__type)) {
              struct sidl_RuntimeException__object *_local_exception = NULL;
              PyObject *_sidlPyException = 
                PyObject_GetAttrString(_exValue, "exception");
              (void)sidl_RuntimeException__convert(_sidlPyException , 
                &_local_exception);
              if (_local_exception) {
                sidl_AddTrace(_sidlPyException, "next_print_time");
                *_exception = (struct sidl_BaseInterface__object 
                  *)_local_exception;
              }
              Py_XDECREF(_sidlPyException);
            }
            else {
              PyErr_Restore(_exType, _exValue, _exTrace);
              *_exception = sidl_Handle_Unexpected("next_print_time");
              _exType = NULL;
              _exValue = NULL;
              _exTrace = NULL;
            }
            Py_XDECREF(_exType);
            Py_XDECREF(_exValue);
            Py_XDECREF(_exTrace);
            PyErr_Clear();
          }
        }
        Py_DECREF(_args);
      } else {
        *_exception = sidl_Handle_Unexpected("next_print_time");
      }
      Py_DECREF(_pfunc);
    } else {
      *_exception = sidl_Handle_Unexpected("next_print_time");
    }
  }
#if (PY_VERSION_HEX >= 0x02040000)
  PyGILState_Release(_gstate);
  sidl_Python_LogGILRelease(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
  return _return;
}

static void
pSkel_PrintQueue_print_all(
  /* in */ struct edu_csdms_tools_PrintQueue__object *self,
  /* in */ double time,
  struct sidl_BaseInterface__object * *_exception
  )
{
  PyObject *_context;
  PyObject *_pfunc;
  PyObject *_args;
  PyObject *_result;
  PyGILState_STATE _gstate;
  *_exception = NULL;
#if (PY_VERSION_HEX >= 0x02040000)
  _gstate = PyGILState_Ensure();
  sidl_Python_LogGILEnsure(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
  if ((_context = (self ? self->d_data : NULL))) {
    if ((_pfunc = PyObject_GetAttrString(_context, "print_all"))) {
      _args =Py_BuildValue(
        "(d)",
        time);
      if (_args) {
        _result = PyObject_CallObject(_pfunc, _args);
        if (_result) {
          int _okay;
          _okay = (_result == Py_None);
          if (_okay) {
          }
          Py_DECREF(_result);
        }
        else {
          if (PyErr_Occurred()) {
            PyObject *_exType, *_exValue, *_exTrace;
            PyErr_Fetch(&_exType, &_exValue, &_exTrace);
            if (PyErr_GivenExceptionMatches(_exType, 
              sidl_RuntimeException__type)) {
              struct sidl_RuntimeException__object *_local_exception = NULL;
              PyObject *_sidlPyException = 
                PyObject_GetAttrString(_exValue, "exception");
              (void)sidl_RuntimeException__convert(_sidlPyException , 
                &_local_exception);
              if (_local_exception) {
                sidl_AddTrace(_sidlPyException, "print_all");
                *_exception = (struct sidl_BaseInterface__object 
                  *)_local_exception;
              }
              Py_XDECREF(_sidlPyException);
            }
            else {
              PyErr_Restore(_exType, _exValue, _exTrace);
              *_exception = sidl_Handle_Unexpected("print_all");
              _exType = NULL;
              _exValue = NULL;
              _exTrace = NULL;
            }
            Py_XDECREF(_exType);
            Py_XDECREF(_exValue);
            Py_XDECREF(_exTrace);
            PyErr_Clear();
          }
        }
        Py_DECREF(_args);
      } else {
        *_exception = sidl_Handle_Unexpected("print_all");
      }
      Py_DECREF(_pfunc);
    } else {
      *_exception = sidl_Handle_Unexpected("print_all");
    }
  }
#if (PY_VERSION_HEX >= 0x02040000)
  PyGILState_Release(_gstate);
  sidl_Python_LogGILRelease(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
}

static void
pSkel_PrintQueue_close(
  /* in */ struct edu_csdms_tools_PrintQueue__object *self,
  struct sidl_BaseInterface__object * *_exception
  )
{
  PyObject *_context;
  PyObject *_pfunc;
  PyObject *_args;
  PyObject *_result;
  PyGILState_STATE _gstate;
  *_exception = NULL;
#if (PY_VERSION_HEX >= 0x02040000)
  _gstate = PyGILState_Ensure();
  sidl_Python_LogGILEnsure(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
  if ((_context = (self ? self->d_data : NULL))) {
    if ((_pfunc = PyObject_GetAttrString(_context, "close"))) {
      _args = PyTuple_New(0);
      if (_args) {
        _result = PyObject_CallObject(_pfunc, _args);
        if (_result) {
          int _okay;
          _okay = (_result == Py_None);
          if (_okay) {
          }
          Py_DECREF(_result);
        }
        else {
          if (PyErr_Occurred()) {
            PyObject *_exType, *_exValue, *_exTrace;
            PyErr_Fetch(&_exType, &_exValue, &_exTrace);
            if (PyErr_GivenExceptionMatches(_exType, 
              sidl_RuntimeException__type)) {
              struct sidl_RuntimeException__object *_local_exception = NULL;
              PyObject *_sidlPyException = 
                PyObject_GetAttrString(_exValue, "exception");
              (void)sidl_RuntimeException__convert(_sidlPyException , 
                &_local_exception);
              if (_local_exception) {
                sidl_AddTrace(_sidlPyException, "close");
                *_exception = (struct sidl_BaseInterface__object 
                  *)_local_exception;
              }
              Py_XDECREF(_sidlPyException);
            }
            else {
              PyErr_Restore(_exType, _exValue, _exTrace);
              *_exception = sidl_Handle_Unexpected("close");
              _exType = NULL;
              _exValue = NULL;
              _exTrace = NULL;
            }
            Py_XDECREF(_exType);
            Py_XDECREF(_exValue);
            Py_XDECREF(_exTrace);
            PyErr_Clear();
          }
        }
        Py_DECREF(_args);
      } else {
        *_exception = sidl_Handle_Unexpected("close");
      }
      Py_DECREF(_pfunc);
    } else {
      *_exception = sidl_Handle_Unexpected("close");
    }
  }
#if (PY_VERSION_HEX >= 0x02040000)
  PyGILState_Release(_gstate);
  sidl_Python_LogGILRelease(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
}

static void
pSkel_PrintQueue_boccaForceUsePortInclude(
  /* in */ struct edu_csdms_tools_PrintQueue__object *self,
  /* in */ int64_t dummy0,
  /* in */ struct gov_cca_TypeMap__object* dummy1,
  /* in */ struct edu_csdms_tools_IRasterOutputFile__object* dummy2,
  /* in */ struct edu_csdms_ports_IRFPort__object* dummy3,
  struct sidl_BaseInterface__object * *_exception
  )
{
  PyObject *_context;
  PyObject *_pfunc;
  PyObject *_args;
  PyObject *_result;
  PyGILState_STATE _gstate;
  *_exception = NULL;
#if (PY_VERSION_HEX >= 0x02040000)
  _gstate = PyGILState_Ensure();
  sidl_Python_LogGILEnsure(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
  if ((_context = (self ? self->d_data : NULL))) {
    if ((_pfunc = PyObject_GetAttrString(_context, 
      "boccaForceUsePortInclude"))) {
#ifdef HAVE_LONG_LONG
      long long int _proxy_dummy0;
#else
      long _proxy_dummy0;
#endif
      _proxy_dummy0 = dummy0;
      _args =Py_BuildValue(
        "("
#ifdef HAVE_LONG_LONG
        "L"
#else
        "l"
#endif
        "O&O&O&)",
        _proxy_dummy0,
        (void *)gov_cca_TypeMap__newRef, dummy1,
        (void *)edu_csdms_tools_IRasterOutputFile__newRef, dummy2,
        (void *)edu_csdms_ports_IRFPort__newRef, dummy3);
      if (_args) {
        _result = PyObject_CallObject(_pfunc, _args);
        if (_result) {
          int _okay;
          _okay = (_result == Py_None);
          if (_okay) {
          }
          Py_DECREF(_result);
        }
        else {
          if (PyErr_Occurred()) {
            PyObject *_exType, *_exValue, *_exTrace;
            PyErr_Fetch(&_exType, &_exValue, &_exTrace);
            if (PyErr_GivenExceptionMatches(_exType, 
              sidl_RuntimeException__type)) {
              struct sidl_RuntimeException__object *_local_exception = NULL;
              PyObject *_sidlPyException = 
                PyObject_GetAttrString(_exValue, "exception");
              (void)sidl_RuntimeException__convert(_sidlPyException , 
                &_local_exception);
              if (_local_exception) {
                sidl_AddTrace(_sidlPyException, "boccaForceUsePortInclude");
                *_exception = (struct sidl_BaseInterface__object 
                  *)_local_exception;
              }
              Py_XDECREF(_sidlPyException);
            }
            else {
              PyErr_Restore(_exType, _exValue, _exTrace);
              *_exception = sidl_Handle_Unexpected("boccaForceUsePortInclude");
              _exType = NULL;
              _exValue = NULL;
              _exTrace = NULL;
            }
            Py_XDECREF(_exType);
            Py_XDECREF(_exValue);
            Py_XDECREF(_exTrace);
            PyErr_Clear();
          }
        }
        Py_DECREF(_args);
      } else {
        *_exception = sidl_Handle_Unexpected("boccaForceUsePortInclude");
      }
      Py_DECREF(_pfunc);
    } else {
      *_exception = sidl_Handle_Unexpected("boccaForceUsePortInclude");
    }
  }
#if (PY_VERSION_HEX >= 0x02040000)
  PyGILState_Release(_gstate);
  sidl_Python_LogGILRelease(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
}

static void
pSkel_PrintQueue__ctor(
  /* in */ struct edu_csdms_tools_PrintQueue__object *self,
  struct sidl_BaseInterface__object * *_exception
  )
{
  PyObject *_context;
  PyObject *_pfunc;
  PyObject *_args;
  PyObject *_result;
  PyGILState_STATE _gstate;
  *_exception = NULL;
#if (PY_VERSION_HEX >= 0x02040000)
  _gstate = PyGILState_Ensure();
  sidl_Python_LogGILEnsure(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
  if ((_context = PyImport_ImportModule("edu.csdms.tools.PrintQueue_Impl"))) {
    if ((_pfunc = PyObject_GetAttrString(_context, "PrintQueue"))) {
      _args = Py_BuildValue("(O&)", (void *)
        edu_csdms_tools_PrintQueue__weakRef, self);
      if (_args) {
        _result = PyInstance_New(_pfunc, _args, NULL);
        if (_result) {
          self->d_data = _result;
          sidl_Python_IncGlobalRef();
        }
        else {
          *_exception = sidl_Handle_Unexpected("_ctor");
        }
        Py_DECREF(_args);
      } else {
        *_exception = sidl_Handle_Unexpected("_ctor");
      }
      Py_DECREF(_pfunc);
    } else {
      *_exception = sidl_Handle_Unexpected("_ctor");
    }
    Py_DECREF(_context);
  } else {
    *_exception = sidl_Handle_Unexpected("_ctor");
  }
#if (PY_VERSION_HEX >= 0x02040000)
  PyGILState_Release(_gstate);
  sidl_Python_LogGILRelease(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
}

/* ctor2, unused in Python. */
static void
pSkel_PrintQueue__ctor2(
  /* in */ struct edu_csdms_tools_PrintQueue__object *self,
  /* in */ void* private_data,
  struct sidl_BaseInterface__object * *_exception
  )
{
  *_exception = NULL;
}
static void
pSkel_PrintQueue__dtor(
  /* in */ struct edu_csdms_tools_PrintQueue__object *self,
  struct sidl_BaseInterface__object * *_exception
  )
{
  PyGILState_STATE _gstate;
  *_exception = NULL;
#if (PY_VERSION_HEX >= 0x02040000)
  _gstate = PyGILState_Ensure();
  sidl_Python_LogGILEnsure(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
  /* Remove only reference to Python object */
  Py_XDECREF(((PyObject *)self->d_data));
#if (PY_VERSION_HEX >= 0x02040000)
  PyGILState_Release(_gstate);
  sidl_Python_LogGILRelease(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
  sidl_Python_DecGlobalRef();
}

#ifdef __cplusplus
extern "C" {
#endif

void
edu_csdms_tools_PrintQueue__impl_set_epv(struct edu_csdms_tools_PrintQueue__epv 
  *epv,
  struct edu_csdms_tools_PrintQueue__pre_epv *pre_epv, struct 
    edu_csdms_tools_PrintQueue__post_epv *post_epv)
{
  _importModules();
  epv->f__ctor = pSkel_PrintQueue__ctor;
  epv->f__ctor2 = pSkel_PrintQueue__ctor2;
  epv->f__dtor = pSkel_PrintQueue__dtor;
  pre_epv->f_initialize_pre = NULL;
  epv->f_initialize = pSkel_PrintQueue_initialize;
  post_epv->f_initialize_post = NULL;
  pre_epv->f_add_files_pre = NULL;
  epv->f_add_files = pSkel_PrintQueue_add_files;
  post_epv->f_add_files_post = NULL;
  pre_epv->f_next_print_time_pre = NULL;
  epv->f_next_print_time = pSkel_PrintQueue_next_print_time;
  post_epv->f_next_print_time_post = NULL;
  pre_epv->f_print_all_pre = NULL;
  epv->f_print_all = pSkel_PrintQueue_print_all;
  post_epv->f_print_all_post = NULL;
  pre_epv->f_close_pre = NULL;
  epv->f_close = pSkel_PrintQueue_close;
  post_epv->f_close_post = NULL;
  pre_epv->f_boccaForceUsePortInclude_pre = NULL;
  epv->f_boccaForceUsePortInclude = pSkel_PrintQueue_boccaForceUsePortInclude;
  post_epv->f_boccaForceUsePortInclude_post = NULL;
}
#ifdef __cplusplus
}
#endif

static struct edu_csdms_tools_IRasterOutputFile__object* 
  pskel_edu_csdms_tools_PrintQueue_fconnect_edu_csdms_tools_IRasterOutputFile(
  const char* url, sidl_bool ar, struct sidl_BaseInterface__object* *_ex) { 
  edu_csdms_tools_IRasterOutputFile__import();
  return edu_csdms_tools_IRasterOutputFile__connectI(url, ar, _ex);
}

static struct edu_csdms_ports_IRFPort__object* 
  pskel_edu_csdms_tools_PrintQueue_fconnect_edu_csdms_ports_IRFPort(const char* 
  url, sidl_bool ar, struct sidl_BaseInterface__object* *_ex) { 
  edu_csdms_ports_IRFPort__import();
  return edu_csdms_ports_IRFPort__connectI(url, ar, _ex);
}

static struct sidl_BaseInterface__object* 
  pskel_edu_csdms_tools_PrintQueue_fconnect_sidl_BaseInterface(const char* url, 
  sidl_bool ar, struct sidl_BaseInterface__object* *_ex) { 
  sidl_BaseInterface__import();
  return sidl_BaseInterface__connectI(url, ar, _ex);
}

static struct gov_cca_TypeMap__object* 
  pskel_edu_csdms_tools_PrintQueue_fconnect_gov_cca_TypeMap(const char* url, 
  sidl_bool ar, struct sidl_BaseInterface__object* *_ex) { 
  gov_cca_TypeMap__import();
  return gov_cca_TypeMap__connectI(url, ar, _ex);
}

#ifdef WITH_RMI
static struct edu_csdms_tools_PrintQueue__rmiExternals s_rmiExtern = {
  pskel_edu_csdms_tools_PrintQueue_fconnect_edu_csdms_ports_IRFPort,
  pskel_edu_csdms_tools_PrintQueue_fconnect_edu_csdms_tools_IRasterOutputFile,
  pskel_edu_csdms_tools_PrintQueue_fconnect_gov_cca_TypeMap,
  pskel_edu_csdms_tools_PrintQueue_fconnect_sidl_BaseInterface
};

#ifdef __cplusplus
extern "C" {
#endif

struct edu_csdms_tools_PrintQueue__rmiExternals *
edu_csdms_tools_PrintQueue__impl_rmi_externals(void) {
  return &s_rmiExtern;
}
#ifdef __cplusplus
}
#endif

#endif /*WITH_RMI*/
